# Fuge Kubernets Emulation Example
This example takes advantage of Fuges DNS server and environment variable injection which emulates that
provided to containers ruinning on Kubernets.

The example system contains an `express.js` based front end and two `restify` based services. The services are deliberately simplistic. One service just adds two numbers and returns the result, the other captures the 
addtion operations that have been performed and records them to a mongodb database running in a docker container.

## Running the system
To run the system you will need docker installed, if you don't have this available you will need to head over to docker.com and install the appropriate binary for your system. Once you have docker ready, take the following
steps to get setup.


```sh
$ docker pull mongo
```

The above will pull the lastet build of the offical mongo container. Next install the process dependencies:

```sh
$ fuge shell fuge/fuge.yml
fuge> apply npm install
```

This takes advantage of the Fuge apply command. This will execute a nominated shell command in each of the named service directories, in this case `npm install` which will setup the dependencies for us.

Once the dependencies have all been installed (this may take a few moments) then we can execute the system with:

```sh
fuge> start all
fuge> ps
name                          type           status         watch          tail
adderservice                  process        running        yes            yes
auditservice                  process        running        yes            yes
webapp                        process        running        yes            yes
mongo                         container      running        no             yes
dns                           internal       running        no             no
```

As with the simple service, the adder service may be exercised by pointing a browser to `http://localhost:3000/add`. The Audit service can be exercised through `http://localhost:3000/audit`.

## Explanation
The difference between this and the simple service is that the `webapp` is discovering services through DNS lookup using a module called `concordant`. Concordant performs DNS lookups in one of two modes depending on the presences of an environment varaible `DNS_HOST`.

If `DNS_HOST` exists then concordant usees `DNS_HOST` and `DNS_PORT` to contact a DNS server directly and perform SRV and A record lookups. If these variables do not exist then concordant will use the system specified DNS resolution.

The fuge configuration file is configured with the following settings:

```
  dns_enabled: true
  dns_host: 127.0.0.1
  dns_port: 53053
  dns_suffix: svc.cluster.local
  dns_namespace: micro
```

Based on these Fuge will inject the `DNS_HOST` and `DNS_PORT` environment variables causing concordant to connect to a dns server on `127.0.0.1` port 53053. These settings also cause fuge to run an internal DNS server that hosts the appropriate SRV and A records required for discovery. To see these run the zone command:

```sh
fuge> zone
type  domain                                           address                                 port
A     adderservice.micro.svc.cluster.local             127.0.0.1                               -
SRV   _main._tcp.adderservice.micro.svc.cluster.local  adderservice.micro.svc.cluster.local    8080
.
.
```

The example above shows the results for the `adderservice`. Note that this is exactly the format that Kubernets uese when generating service lookup DNS entries.

In production Concordant will use the system supplied DNS configuration which will of course be supplied by Kubernetes.

The file `webapp/helper.js` shows how Concordant works with Fuge to emulate kubernetes.

Finally take a look at `adderservice/wiring.js` note that it uses the environment variable `ADDERSERVICE_SERVICE_PORT` to determine the port to listen on. This is generated by fuge and will also be generated by Kubernetes in a production environment. To see the environment variables that will be injected into for example the `webapp` process run:

```sh
fuge> info webapp full
```

## Summary
This example shows how Fuge can be used to emulate a Kubernetes production environment. The Key point for doing this is to provide a rapid process based development environment that is very close to production. The code in this example for instance will run unchanged in a production Kubernets cluster.

